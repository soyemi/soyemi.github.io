<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>hackintosh-installation</title>
      <link href="/2018/04/12/hackintosh-installation/"/>
      <url>/2018/04/12/hackintosh-installation/</url>
      <content type="html"><![CDATA[<p>经历两天的挣扎终于重装了无限重启的黑苹果，做个小笔记。</p><p>公司用来做CI的黑苹果一直是长时间待机状态的。由于要安装TeamCity重启了一下就陷入了无限重启循环。原因估计是驱动问题导致的无法进入系统。<br>在Clover界面选择启动项开启SafeMode可以进入系统，但是显卡驱动异常（也可能是由于安全模式没有加载Kext）。</p><p>原先配置安装Hackintosh的Xiao老师离职之后，公司似乎就没有能够修复黑苹果的人了，不过问到了一个网站。</p><p><a href="https://tonymacx86.com" target="_blank" rel="noopener">tonymacx86</a></p><p>试图使用MultiBeast重刷一份efi驱动看能否正常进入系统，事实告诉我失败了。MultiBeast 无法在safe mode下运行。<br>手动mount efi的Volume也会失败。由于safe mode的安全机制无法加载msdos的filesystem，导致无法挂载。</p><h1 id="重装系统准备条件"><a href="#重装系统准备条件" class="headerlink" title="重装系统准备条件"></a>重装系统准备条件</h1><p>首先需要一台正常的Mac电脑。</p><p>需要的软件。</p><p>Clover boot loader efi引导程序，模拟苹果硬件环境使得原版macos镜像可以正常安装运行。<br>UniBeast  制作Clover 启动U盘的工具。（其实不是必须的）<br>MultiBeast 安装完系统后用来刷efi和安装驱动的工具</p><p>下载MacOS 10.13.3 high sierra.dmg 安装镜像。可以在MacStore上下载，这种方式需要开启ActivityMonitor查找实际下载的文件路径。<br>或者从网上下载他人分享的镜像。</p><h1 id="制作启动U盘"><a href="#制作启动U盘" class="headerlink" title="制作启动U盘"></a>制作启动U盘</h1><p>首先格式化U盘，U盘需要至少16G的大小。<br>格式化为 MacOS Extended (Journaled) Scheme: GUID Partition Map</p><p>mount macos的dmg 将install macos high sierra.app 拖动到Application下面。</p><p>Launch UniBeast, 选择UEFI boot 然后选择要安装的系统 High Sierra. 最后等待制作成功，这个过程大概 15-30mins (时间较长耐心等待，我之前一直是等了4-5分钟以为stuck就关闭了)。</p><p>另一种比较快速的方式是下载网络上已经集成好clover的dmg，格式化好U盘后直接copy就好。</p><h1 id="安装MacOS"><a href="#安装MacOS" class="headerlink" title="安装MacOS"></a>安装MacOS</h1><p>BIOS 设置 disable vt-d, disable secure boot.</p><p>将U盘插入hackintosh后（最好用USB2.0,避免兼容性问题），在BIOS中选择用U盘引导。成功进入Clover界面后不要马上选择安装系统。先到option的页面PCI,<code>Check USB-Ownership</code>和<code>USB-injection</code>.<br>记住在没有用MultiBeast装好驱动之前都需要勾选。</p><p>然后选择带External Icon的启动项launch macos install. 按Spacebar进入launch options 页面，如果hackintosh没有独显一定记得<code>uncheck set Nvidia to vesa</code>. 然后启动安装启动项。<br>这时候会有loading bar 结束后就会进入mac系统的安装界面。</p><p>具体的安装流程就是先使用diskutil格式化要安装的磁盘，这里是Samsung SSD，然后等待10-20分钟安装完成。完成后会自动reboot.</p><p>如果loading bar卡住，或者任何的异常，可以在launch option里面勾选verbose. 这样就会输出kext的debug log, 便于定位问题。</p><p>installation完成之后会自动reboot 这个时候记得BIOS依旧选择U盘启动，同时勾选两个USB option. 如果一切正常读条完成后就会进入mac configuration页面。这步骤结束之后又会reboot一次，就可以看到launch macos from MacHD(Disk name).</p><p>这时候记得还是要配置launch option.进入系统之后就是创建系统用户了，到此安装系统就结束了。</p><h1 id="安装驱动"><a href="#安装驱动" class="headerlink" title="安装驱动"></a>安装驱动</h1><p>进入系统后会发现显卡驱动不正常，启动MultiBeast 选择对应的网卡声卡以及显卡等驱动，等待安装结束后，efi中的驱动信息就被更新了。这个时候reboot.在BIOS中将启动项顺序切回SSD上的 UEFI。在进入Clover之后就会自动选择使用MacOS 启动，等待读条配置后使用MultiBeast的驱动就生效了，检查显卡是否正常。这时候就不再需要UniBeast来引导了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整个安装流程会由于hackintosh的硬件配置不同而出现各种不一样的问题。例如那个Nvidia driver 的选项在Xiao老师安装的时候是默认不勾选的，而我安装时时默认勾选的。但是由于我们的机器只有intel的核显，所以勾选就会出现<code>please switch to XPC</code>的错误，导致安装流程卡住。所以具体的情况具体分析，开始kernel log多google 问题就好了。</p><p>References</p><p><a href="http://hk2.zeddal.com/2017/11/29/hackintosh-installation-session/" target="_blank" rel="noopener">Blog of Xiao</a><br><a href="https://tonymacx86.com" target="_blank" rel="noopener">tonymacx86</a><br><a href="https://www.tonymacx86.com/threads/10-11-0-10-11-3-skylake-starter-guide.179221/" target="_blank" rel="noopener">Skylake Starter Guide</a><br><a href="https://blog.daliansky.net/macOS-High-Sierra-10.13.3-%2817D47%29-official-version-and-Clover-4391-original-image.html" target="_blank" rel="noopener">macOS High Sierra 10.13.3 mirror</a></p>]]></content>
      
      
        <tags>
            
            <tag> Other </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NPR油画风格着色器</title>
      <link href="/2018/03/11/shader-npr-oilpaint/"/>
      <url>/2018/03/11/shader-npr-oilpaint/</url>
      <content type="html"><![CDATA[<p><img src="/images/shader-npr_oilpaint.png" alt="oilpaint-rendeirng"></p><p>非真实感风格化处理通常是降低像素的精度，减少细节或者以特殊的纹理进行覆盖。油画风格的特点为块状的笔触与色块，将画面色块化的方式一种是降低图像的色阶，但是使用这种方式会减少画面颜色的数量，与原图有较大的偏差的丢失。而使用类似聚类算法，将临近像素的颜色进行合并和混合可以达到较好的效果。</p><p>整体的计算流程是，对于一个像素，计算它相邻的10 * 10范围内的所有像素，取每个像素的RGB值之和取均值。将这些均值映射到20个梯度至内，每个像素落到一个梯度值就累加上像素颜色的值，同时梯度的索引加一。当遍历完所有的像素之后，选取索引次数最高的梯度的所有像素的平均值，作为该像素的颜色。</p><p>Unity ShaderLab中实现的具体代码如下:</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Shader "Yemi/OilpaintShader" &#123;</span><br><span class="line">Properties &#123;</span><br><span class="line">_MainTex ("Albedo (RGB)", 2D) = "white" &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">SubShader &#123;</span><br><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">Name "Pass1"</span><br><span class="line">CGPROGRAM</span><br><span class="line"><span class="meta">#pragma vertex vert_img  </span></span><br><span class="line"><span class="meta">#pragma fragment frag </span></span><br><span class="line"><span class="meta">#pragma fragmentoption ARB_precision_hint_fastest  </span></span><br><span class="line"><span class="meta">#include "UnityCG.cginc"          </span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> _MainTex;</span><br><span class="line"></span><br><span class="line">half4 frag(v2f_img i) : COLOR</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">20</span>] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line">half4 c[<span class="number">20</span>] = &#123;</span><br><span class="line">half4(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),half4(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),half4(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),half4(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),half4(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),</span><br><span class="line">half4(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),half4(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),half4(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),half4(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),half4(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),</span><br><span class="line">half4(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),half4(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),half4(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),half4(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),half4(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),</span><br><span class="line">half4(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),half4(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),half4(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),half4(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),half4(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">-5</span>; x &lt;= <span class="number">5</span>; x++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">-5</span>; y &lt;= <span class="number">5</span>; y++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">half4 p1 = tex2D(_MainTex, i.uv + <span class="number">0.001</span>*half2(x,y));</span><br><span class="line"><span class="type">int</span> pi1 = <span class="type">int</span>((p1.r + p1.g + p1.b)/<span class="number">3.0</span> * <span class="number">19</span>);</span><br><span class="line">a[pi1] ++;</span><br><span class="line">c[pi1] += p1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="keyword">index</span> = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="built_in">max</span> = a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; <span class="number">20</span>; n++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[n] &gt;= <span class="built_in">max</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">max</span> = a[n];</span><br><span class="line"><span class="keyword">index</span> = n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">half4 oc = c[<span class="keyword">index</span>] / <span class="built_in">max</span>;</span><br><span class="line">oc.a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> oc;</span><br><span class="line">&#125;</span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">FallBack "Diffuse"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于每个像素要对贴图进行多达100次的采样和大量的计算该shader的耗时太长，不能实时运行。可以考虑将Framebuffer downsample之后进行采样，同时再加入随机值减少贴图采样的次数。</p>]]></content>
      
      <categories>
          
          <category> Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shader </tag>
            
            <tag> NPR </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SharpDX中的Buffer更新</title>
      <link href="/2018/01/30/buffer-updating-on-sharpdx/"/>
      <url>/2018/01/30/buffer-updating-on-sharpdx/</url>
      <content type="html"><![CDATA[<p>最近在用C#写一个基于图形API的UI库，底层用的是Managed的DX库SharpDX。由于UI绘制会在每一个UI事件重绘，更新Buffer变得十分的频繁。在调试的过程中时不时会遇到一个C#的<code>System.AccessViolationException</code>。这个异常是用了<code>Intptr</code>指针在非托管层调用时越界导致的，搜索了很久最后还是自己思考下想通了。</p><p>调用的接口是<code>DeviceContext.UpdateSubresources</code>，在SharpDX中的代码如下。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rawbuffer = buffer.GetRawObject() <span class="keyword">as</span> Buffer;</span><br><span class="line"><span class="keyword">if</span> (rawbuffer == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line"><span class="keyword">var</span> pinnedptr = GCHandle.Alloc(data, GCHandleType.Pinned);</span><br><span class="line">m_obj.UpdateSubresourceSafe(<span class="keyword">new</span> DataBox()</span><br><span class="line">&#123;</span><br><span class="line">  DataPointer = pinnedptr.AddrOfPinnedObject()</span><br><span class="line">&#125;,rawbuffer,subresources);</span><br><span class="line">pinnedptr.Free();</span><br></pre></td></tr></table></figure><p>其中<code>data</code>是一个数组，<code>rawbuffer</code>是一个vertexBuffer。我们先使用<code>GCHandler</code>把数组的内存位置固定住，然后将指针传递给DX,从指针位置拷贝数据到VertexBuffer中，最后释放Pin住的数组。之前在写代码的时候并没有考虑太多，忽略了这里的更新Buffer并没有传递拷贝的地址长度的参数。也就是说拷贝数据的时候是按照DX中Buffer的大小来进行复制的，而不是这个data对象的大小。这样由于data在托管内存中，当Buffer的大小大于data的大小时，拷贝的指针就会越界，从而抛出异常。</p><p>回头来看DirectX 11中的Buffer在创建Buffer的时候，有一个参数是Usage，这里我们只讨论<code>D3D11_USAGE_DEFAULT</code>和<code>D3D11_USAGE_DYNAMIC</code>。在Default的Buffer可使用<code>UpdateSubresources</code>的接口来更新Buffer数据，同时这个更新只能是一次性更新整个Buffer，就是上面说到的情况，不能只更新部分。而对于需要频繁动态更新的Buffer设置为<code>D3D11_USAGE_DYNAMIC</code>，图形API会进行性能优化，同时可以使用<code>Map</code>和<code>UnMap</code>来更新Buffer数据。 </p>]]></content>
      
      <categories>
          
          <category> Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> DirectX </tag>
            
            <tag> SharpDX </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C# 中实现一个独立的partial class</title>
      <link href="/2017/11/18/csharp-independent-partial-class-hack/"/>
      <url>/2017/11/18/csharp-independent-partial-class-hack/</url>
      <content type="html"><![CDATA[<p>今天想要分享的是的是一个关于C#的hack，其实题目也想了好久并不知道如何描述这样一个东西。大致的描述就是我们需要一个partial的类，这个类被定义在两个.cs文件中，当两个文件同时编译或者是单个编译时不会有compile error。同时这两个文件有相同的完全的capabilities(大概可以用这个词来描述)。</p><p>其实这个需求不是十分直观的，只有在特定的环境下才会有这种需求。我们在Unity的项目中，定义了一个类来处理版本号，暂且定为ClassVersion。同时我们还有一个模块A，这个模块也需要依赖ClassVersion来定义一个版本号。所以当只有模块A时我们也需要ClassVersion的定义。但是如果当模块A导入到Unity项目中时，同样的定义就会出现SymbolRedefinded。在这种环境下，最终使用了一个十分hack的方式，在不使用反射的情况下满足了需求。</p><h2 id="尝试Partial"><a href="#尝试Partial" class="headerlink" title="尝试Partial"></a>尝试Partial</h2><p>很显然一来想到的是C#中的Partial。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//Unity classVersion_unity.cs</span></span><br><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">ClassVersion</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetMajor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//ModuleA classVersion_moduleA.cs</span></span><br><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">ClassVersion</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetMajor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样ClassVersion在各自独立的时候是正常的工作的，但是在合并时还是有<code>GetMajor()</code>这个方法的重定义。如果在不用反射，不使用不同函数名的情况下，始终是会有编译错误的。同时partial method 在这里也没有办法，partial method只能实现一次，所以一定有一边缺少实现。</p><h2 id="使用interface"><a href="#使用interface" class="headerlink" title="使用interface"></a>使用interface</h2><p>尝试把class 改成interface，两个partial的Interface在去掉是现实还是会有相同method的编译报错。不过最后发现了一个常常被忽略的特性。如果有两个接口，他们有相同的方法声明，那么一个实现这两个接口的类只要实现一次这样的方法，并且也不会有编译错误，具体的代码如下。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IVersionA</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetMajor</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IVersionB</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetMajor</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">public class ClassVersion: IVersionA,IVersionB&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetMajor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样我们就可以避开method重定义的Compile Error了。</p><h2 id="创建两个互补的-partial-interface"><a href="#创建两个互补的-partial-interface" class="headerlink" title="创建两个互补的 partial interface"></a>创建两个互补的 partial interface</h2><p><strong>Unity classVersion_unity.cs</strong><br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">interface</span> <span class="title">IVersionA</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">interface</span> <span class="title">IVersionB</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetMajor</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public partial class ClassVersionUnity :IVersionA,IVersionB&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetMajor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>ModuleA classVersion_moduleA.cs</strong><br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">interface</span> <span class="title">IVersionA</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetMajor</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">interface</span> <span class="title">IVersionB</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public partial class ClassVersionModuleA :IVersionA,IVersionB&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetMajor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样这两个.cs文件在独立编译与同时编译的情况下都不会有编译报错<br>在各自的环境中，只要转换为当前环境中带有实现的那个接口对象就可以直接调用方法了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这种实现方式看起来并不优雅，代码的实现还是两份，这个是无法避免的。但是避免了使用反射和强制类型转换，使用接口限定了实现，总之一个比较hack的实现方式。</p>]]></content>
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> C# </tag>
            
            <tag> hack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用cmake构建visual studio项目</title>
      <link href="/2017/10/04/cmake-notes/"/>
      <url>/2017/10/04/cmake-notes/</url>
      <content type="html"><![CDATA[<p>之前在写c++项目的时候，一直使用的是宇宙第一IDE Visual Studio，vs确实默默在后台做了许多事情，你只用管写代码其他的都不用操心。但是当项目引入大量的第三方库的时候，许多构建相关的配置就会比较麻烦。考虑到Rigel(一个巨大的轮子)这个项目后续需要支持多平台构建，所以打算试试使用cmake组织整个工程。</p><p>对于cmake使用其实没有太多经验的，主要是之前在编译一些第三方库的时候，libpng freetype之类的。一行命令行脚本 <code>cmake ./</code> 然后自动生成了sln项目，后面就是熟悉的visual studio了。</p><a id="more"></a><h2 id="cmake初体验"><a href="#cmake初体验" class="headerlink" title="cmake初体验"></a>cmake初体验</h2><h3 id="创建cmake工程"><a href="#创建cmake工程" class="headerlink" title="创建cmake工程"></a>创建cmake工程</h3><p>在项目目录下创建一个<code>CMakeLists.txt</code>创建好了一个cmake工程。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指定cmake的最小版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.2</span>)</span><br><span class="line"><span class="comment">#制定项目的名称</span></span><br><span class="line"><span class="keyword">project</span>(Rigel)</span><br></pre></td></tr></table></figure><p>在一个大型的项目中可能会有很多子工程，就类似于vs中的解决方案和项目的关系。可以对每个子项目指定一个<code>CMakeLists.txt</code>文件，子项目可以是一个静态库动态库或者是可执行程序等等。</p><p>在主的CMakeLists文件中添加<code>add_subdirectory([sub folder path])</code> 就可以引入子工程的配置。</p><h3 id="配置生成的项目"><a href="#配置生成的项目" class="headerlink" title="配置生成的项目"></a>配置生成的项目</h3><p>接下来就要添加项目了<br><code>add_executable([target name] [source files...])</code> add_executable可以为项目添加一个可执行工程<br><code>add_library([target name] [source files...])</code> 对于项目中静态库和动态库可以使用add_library进行添加</p><p>如果项目只有一个<code>main.cpp</code> 那么<code>add_executable(testproj main.cpp)</code>，生成的sln中就会把main.cpp添加到testproj这个项目的源文件下面。</p><p>项目依赖配置<br>我们可以指定一个target依赖其他的库项目的target<br><code>add_dependencies(RigelEditor rgcore)</code></p><h3 id="多源文件的配置"><a href="#多源文件的配置" class="headerlink" title="多源文件的配置"></a>多源文件的配置</h3><p>如果有多个源文件可以直接在source files里面添加<code>add_executable(testproj xxx1.cpp xxx2.cpp...)</code>。</p><p>当然可以使用<code>aux_source_directory([Path] [Variable])</code>命令来获取一个目录下的的所有源文件 然后储存在变量<code>Variable</code>中</p><p>还可以使用<code>FILE()</code> 方法来获取<br>几个简单的例子<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE(GLOB HEAD_RIGEL_EDITOR ./<span class="keyword">include</span>/*.h)  <span class="comment">#GLOB 获取./include/目录下的*.h 储存在变量HEAD_RIGEL_EDITOR中</span></span><br><span class="line">FILE(GLOB_RECURSE SRCS_RIGEL_EDITOR ./source/*.cpp)<span class="comment">#GLOB 递归获取./include/目录和子目录下的*.cpp 储存在变量HEAD_RIGEL_EDITOR中</span></span><br></pre></td></tr></table></figure></p><p><code>add_executable(testproj ${HEAD_RIGEL_EDITOR} ${SRCS_RIGEL_EDITOR})</code><br>这样我们就可以给项目添加多个源文件了</p><p><strong>CMAKE生成的sln工程中不会把源文件拷贝到build的目录中，而是通过引用文件的方式</strong></p><h3 id="引用路径与库目录"><a href="#引用路径与库目录" class="headerlink" title="引用路径与库目录"></a>引用路径与库目录</h3><p>我们添加了一个子项目后还需要设置include的路径，来添加对头文件的引用。<br><code>target_include_directories(RigelEditor PUBLIC ./include/rgeditor)</code><br>这样就给RigelEditor这target添加了一个include的路径<code>./include/rgeditor</code>。</p><p>添加link的库文件<br><code>target_link_libraries(RigelEditor rgcore)</code><br>如果需要添加第三方的库文件,可以直接引用库文件的路径。</p><p>需要注意的是使用CMAKE_SOURCE_DIR可以获取到源文件的目录而不是生成的目录。</p><p><code>target_link_libraries(rgcore ${THIDPART_LIB_DIR}\\freetype\\libs\\x64\\freetype28.lib)</code></p><h2 id="cmake其他配置"><a href="#cmake其他配置" class="headerlink" title="cmake其他配置"></a>cmake其他配置</h2><h3 id="源文件分组"><a href="#源文件分组" class="headerlink" title="源文件分组"></a>源文件分组</h3><p>在visual studio中我们可以添加筛选器给源文件进行分组。cmake提供了<code>source_group()</code>来支持这一特性。</p><p><code>source_group</code>需要写在<code>add_library</code>或者<code>add_executable</code>之后<br>下面是使用的示例：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FILE(GLOB SRCS_RGGRAPHICS_CORE ./source/*.cpp)</span><br><span class="line">FILE(GLOB SRCS_RGGRAPHICS_DIRECTX11 ./source/directx11/*.cpp)</span><br><span class="line"></span><br><span class="line">FILE(GLOB HEAD_RGGRAPHICS_CORE ./<span class="keyword">include</span>/rggraphics/*.h)</span><br><span class="line">FILE(GLOB HEAD_RGGRAPHICS_DIRECTX11 ./<span class="keyword">include</span>/rggraphics/directx11/*.h)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(rggraphics STATIC <span class="variable">$&#123;HEAD_RGGRAPHICS&#125;</span> <span class="variable">$&#123;SRCS_RGGRAPHICS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">source_group</span>(<span class="string">"source\\core"</span> FILES <span class="variable">$&#123;SRCS_RGGRAPHICS_CORE&#125;</span>)</span><br><span class="line"><span class="keyword">source_group</span>(<span class="string">"source\\directx11"</span> FILES <span class="variable">$&#123;SRCS_RGGRAPHICS_DIRECTX11&#125;</span>)</span><br><span class="line"><span class="keyword">source_group</span>(<span class="string">"header\\core"</span> FILES <span class="variable">$&#123;HEAD_RGGRAPHICS_CORE&#125;</span>)</span><br><span class="line"><span class="keyword">source_group</span>(<span class="string">"header\\directx11"</span> FILES <span class="variable">$&#123;HEAD_RGGRAPHICS_DIRECTX11&#125;</span>)</span><br></pre></td></tr></table></figure></p><p><code>set_property(GLOBAL PROPERTY USE_FOLDERS ON)</code>打开USE_FOLDERS的配置</p><p><img src="/images/cmake_source_group.png" alt="cmake source_group"></p><h3 id="判定编译的Architecture"><a href="#判定编译的Architecture" class="headerlink" title="判定编译的Architecture"></a>判定编译的Architecture</h3><p>有时候我们的配置需要区别64位与32位，如一些静态库动态库的版本不同，就需要在cmake中判断当前配置是否是64位。<br>CMAKE提供了<code>CMAKE_CL_64</code>这个变量来判定<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(CMAKE_CL_64)</span><br><span class="line">    <span class="comment">#link 64位库文件</span></span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="comment">#link 32位库文件</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></p><h3 id="Configuration-Debug-Release的判定"><a href="#Configuration-Debug-Release的判定" class="headerlink" title="Configuration Debug/Release的判定"></a>Configuration Debug/Release的判定</h3><p>有时候我们需要区别Debug/Release build<br><code>$&lt;$&lt;CONFIG:DEBUG&gt;:${BUILD_DIR_RIGELEDITOR_DEBUG}&gt;$&lt;$&lt;CONFIG:RELEASE&gt;:${BUILD_DIR_RIGELEDITOR_RELEASE}&gt;</code><br>这个值在Debug的配置下输出${BUILD_DIR_RIGELEDITOR_DEBUG}在Release下则是<br>${BUILD_DIR_RIGELEDITOR_RELEASE}</p><h3 id="指定build输出目录"><a href="#指定build输出目录" class="headerlink" title="指定build输出目录"></a>指定build输出目录</h3><p>生成sln会给每个子项目生成自己的输出路径一般情况下是<br><code>$(ProjectDir)$(PlatformTarget)$(Configuration)</code><br>如<code>TestProj/x64/Debug</code>这样的路径<br>在cmake中我们可以制定一个target生成的路径便于我们执行post-build的脚本来做一些处理</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set_target_properties</span>(RigelEditor PROPERTIES </span><br><span class="line">    RUNTIME_OUTPUT_DIRECTORY_DEBUG <span class="variable">$&#123;BUILD_DIR_RIGELEDITOR_DEBUG&#125;</span></span><br><span class="line">    RUNTIME_OUTPUT_DIRECTORY_RELEASE <span class="variable">$&#123;BUILD_DIR_RIGELEDITOR_RELEASE&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="自定义命令处理post-build"><a href="#自定义命令处理post-build" class="headerlink" title="自定义命令处理post-build"></a>自定义命令处理post-build</h3><p>项目生成之后如果有文件需要拷贝，在vs中可以使用生成事件-后期生成事件-命令行来添加命令。cmake中也可以指定这样的生成事件的配置。</p><p><code>add_custom_command(TARGET RigelEditor POST_BUILD COMMAND xcopy ARGS ${CMD_COPY_DATA})</code><br>这样指定了RigelEditor在Post Build阶段执行 xcopy的命令行 参数为 ${CMD_COPY_DATA}</p><p>生成sln之后再后期生成事件中就可以看到cmake添加的命令<br><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setlocal</span></span><br><span class="line"><span class="built_in">xcopy</span> "F:/_Proj_RgEngine/ProjRigel/Rigel\resources\Data" "F:/_Proj_RgEngine/ProjRigel/Build/win64\Build\RigelEditor_Debug\Data\" /E /Y</span><br><span class="line"><span class="keyword">if</span> <span class="variable">%errorlevel%</span> <span class="keyword">neq</span> <span class="number">0</span> <span class="keyword">goto</span> :cmEnd</span><br><span class="line">:cmEnd</span><br><span class="line"><span class="built_in">endlocal</span> &amp; <span class="keyword">call</span> :cmErrorLevel <span class="variable">%errorlevel%</span> &amp; <span class="keyword">goto</span> :cmDone</span><br><span class="line">:cmErrorLevel</span><br><span class="line"><span class="keyword">exit</span> /b %<span class="number">1</span></span><br><span class="line">:cmDone</span><br><span class="line"><span class="keyword">if</span> <span class="variable">%errorlevel%</span> <span class="keyword">neq</span> <span class="number">0</span> <span class="keyword">goto</span> :VCEnd</span><br></pre></td></tr></table></figure></p><h2 id="cmake杂项"><a href="#cmake杂项" class="headerlink" title="cmake杂项"></a>cmake杂项</h2><p>###VC++ Unicode支持<br>在vc++中定义<code>UNICODE</code>与<code>_UNICODE</code>这两个宏，字符串就自动使用了宽字节版本的。所以我们需要在cmake中设定宏，否则编译会报错，使用visual stuido直接创建项目时会直接帮我们设置的好(再一次赞美下VisualStudio)<br><code>add_definitions(-DUNICODE -D_UNICODE)</code></p><p>###Visual Studio中配置预编译头<br>vs中通过配置预编译头文件加快项目的编译速度。可以通过设置Compile Flags /Yc /Yu添加预编译头的配置</p><p>使用CMake进行构建时,<code>set_source_files_properties</code>命令可以对源文件添加编译器参数</p><p>为了给多个子项目都配置预编译头文件，使用CMake的macro来批量处理。<br>定义两个macro <code>set_pch</code> <code>use_pch</code><br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">macro</span>(set_pch VARCPP VARHEADER)</span><br><span class="line">    <span class="keyword">set_source_files_properties</span>(<span class="variable">$&#123;VARCPP&#125;</span> PROPERTIES COMPILE_FLAGS <span class="string">"/Yc$&#123;VARHEADER&#125;"</span>)</span><br><span class="line"><span class="keyword">endmacro</span>(set_pch)</span><br><span class="line"><span class="keyword">macro</span>(use_pch VARSOURCES VARHEADER)</span><br><span class="line">    <span class="keyword">foreach</span>( src_file <span class="variable">$&#123;VARSOURCES&#125;</span>)</span><br><span class="line">        <span class="keyword">set_source_files_properties</span>(<span class="variable">$&#123;src_file&#125;</span> PROPERTIES COMPILE_FLAGS <span class="string">"/Yu$&#123;VARHEADER&#125;"</span>)</span><br><span class="line">    <span class="keyword">endforeach</span>( src_file <span class="variable">$&#123;VARSOURCES&#125;</span>)</span><br><span class="line"><span class="keyword">endmacro</span>(use_pch VARHEADER VARSOURCES)</span><br></pre></td></tr></table></figure></p><p>使用方式<br>假设预编译头文件为stdafx.h则所有的.cpp文件除了stdafx.cpp需要设置 /Yustdafx.h，使用预编译头。<br>stdafx.cpp设置 /Ycstdafx.h，生成预编译头。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use_pch(<span class="string">"$&#123;SRCS_RGCORE&#125;"</span> <span class="string">"rgcore.h"</span>)</span><br><span class="line">set_pch(./source/rgcore.cpp <span class="string">"rgcore.h"</span>)</span><br></pre></td></tr></table></figure><p><strong>一个常见的错误 调用cmake中的方法与宏时 如果需要传入的参数为数组 正确的写法应该是<code>&quot;${VARNAME}&quot;</code> 而不是<code>${VARNAME}</code></strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大概花了半天的时间将<a href="https://github.com/ProgRigel/ProjRigel" target="_blank" rel="noopener">Rigel</a> 从sln迁移到了cmake来构建。上文大概就是在配置过程中遇到的坑以及解决的方法的总结，提及到的cmake命令可以满足基本的项目构建了。<br>cmake使用起来感觉确实很方便，比起直接设置vs sln中的配置之类的，后续应该就会都用cmake了吧。</p><hr><p>更新记录</p><ul><li>2017-10-04 文章发布</li><li>2017-10-13 添加了Visual Stdudio 预编译头配置</li></ul>]]></content>
      
      <categories>
          
          <category> Continuous Integration </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmake </tag>
            
            <tag> visual studio </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>在Visual Studio中自定义预编译头文件</title>
      <link href="/2017/09/14/vs-precompiled-header/"/>
      <url>/2017/09/14/vs-precompiled-header/</url>
      <content type="html"><![CDATA[<p>预编译头文件可以加快整个工程的编译速度，对于大型项目来说尤为重要。将大部分不太变化的头文件在预编译头文件中定义，会减少这部分头文件重新编译的时间。</p><p>VC++中创建win32工程时如果配置了开启预编译头文件会自动生成一个Stdafx.h以及对应的Stdafx.cpp。同时需要在整个项目中的所有cpp源文件引用该头文件。如缺少了引用则会抛出错误<code>C1010: 在查找预编译头时遇到意外的文件结尾。</code></p><p>由于先前在编写项目时创建的是一个空项目，就需要在后来指定pch。打开项目属性页选择C/C++/预编译头。配置预编译头文件为自定义的头文件，如rgcore.h 同时在第一栏的预编译头的配置中选择 <code>使用/Yu</code>。</p><p>对于rgcore.h这个预编译头文件对应的rgcore.cpp右键该文件打开配置在相同的位置选择 <code>创建/Yc</code></p><p>如果对应的.cpp文件也是设置为<code>使用/Yu</code> 则会抛出<code>C1854: 无法覆盖在创建对象文件“rgcore.obj”的预编译头过程中形成的信息</code></p><a id="more"></a>]]></content>
      
      <categories>
          
          <category> Continuous Integration </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Visual Studio </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DirectX-DeferredContext与multipass rendering</title>
      <link href="/2017/09/11/directx-note-2/"/>
      <url>/2017/09/11/directx-note-2/</url>
      <content type="html"><![CDATA[<p>DirectX11中有两种渲染方式，Immediate Rendering与Deferred Rendering。这里的延迟渲染与 实时渲染中的延迟渲染不是同一种概念，DX中的Deferred Context是在图像api层面绘制指令DrawCall的延迟，而实时渲染中的Deferred Rendering是利用GBuffer对渲染对象进行延迟着色。Deferred Context可以用来实现多线程渲染，最大程度上利用CPU与GPU的性能。</p><h2 id="多线程渲染"><a href="#多线程渲染" class="headerlink" title="多线程渲染"></a>多线程渲染</h2><p>多线程渲染在我看来强调的是CPU层面的多线程，而GPU的渲染指令都是顺序执行的，而渲染本身由于GPU并行计算的架构始终是多线程的。在游戏运行的过程中，每一帧都有大量繁重的计算，CPU端的逻辑预算和GPU端的绘制。而游戏运行的帧率取决于最慢的一方。对于渲染的流程来说，CPU将绘制的图元数据传递到GPU然后GPU收到绘制指令开始绘制。这一流程是有先后顺序的。每个CPU调用绘制或者是设置渲染状态的命令都需要等待GPU完成后才能执行下一个命令。</p><p>CPU端的多线程在于可以开启多个线程同时创建好一系列的指令并且做好CPU端的所有准备工作。然后再将这些指令列表顺序提交给GPU。这样就可以减少调用图像指令的同步时间，以减少CPU的时间消耗。</p><a id="more"></a><p>D3D11中可以创建多个DeferredContext, 可以对DeferredContext调用所有的渲染管线状态设置以及绘制的命令。然后将其储存在一个Command List中。 最后在执行真正的绘制时使用ImmediateContext执行CommandList。就可以一次性把一批次指令提交GPU。这里需要注意的是ImmediateContext本身不是线程安全的。</p><p>类似于Unity中的CommandBuffer可以将一系列绘制命令提交给GPU执行，但是在Unity中CommandBuffer只是在上层应用层提供渲染管线扩展的能力。多线程渲染的另一个用处是可以将所有的绘制分割成不同的渲染任务，每个任务在各自命令列表中进行调用，维护独立的渲染管线状态。避免上一个绘制指令的管线状态影响到后续的绘制。</p><h2 id="Multipass渲染"><a href="#Multipass渲染" class="headerlink" title="Multipass渲染"></a>Multipass渲染</h2><p>Multipass(多通道渲染，不知道是不是比较准确的翻译)渲染是一个更加上层的概念。在图像API层面并没有多通道渲染的概念。OpenGL D3D等等底层API没有相应的对象和接口，就像我们在游戏引擎里面看到的材质Material，也是应用层抽象出来的概念。</p><p>在Unity ShaderLab的语法中我们可以这样定义一个Shader。Shader中支持MultiPass,几乎所有的游戏引擎都支持MultiPass。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Shader&#123;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        Pass&#123;</span><br><span class="line">            //Pass 1</span><br><span class="line">        &#125;</span><br><span class="line">        Pass&#123;</span><br><span class="line">            //Pass</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么为什么需要多通道渲染呢？之前和老大讨论之后，有了一些更深的理解。</p><h3 id="多通道渲染的实现"><a href="#多通道渲染的实现" class="headerlink" title="多通道渲染的实现"></a>多通道渲染的实现</h3><p>多通道渲染是对图像API的组织结构，例如在DX11中渲染一个对象，通常的做法如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">deviceContext-&gt;SetVertexBuffer();</span><br><span class="line">deviceContext-&gt;SetIndicesBuffer();</span><br><span class="line">deviceContext-&gt;SetVertexShader();</span><br><span class="line">deviceContext-&gt;SetPixelShader();</span><br><span class="line">deviceContext-&gt;SetPipelineState();</span><br><span class="line"></span><br><span class="line">deviceContext-&gt;DrawIndices(); <span class="comment">//draw call</span></span><br></pre></td></tr></table></figure></p><p>先设置绘制的buffer数据然后进行设置shader最后调用draw call。而MultiPassShader的流程是<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">deviceContext-&gt;SetVertexBuffer();</span><br><span class="line">deviceContext-&gt;SetIndicesBuffer();</span><br><span class="line"></span><br><span class="line">deviceContext-&gt;SetVertexShader();   <span class="comment">//Pass 1</span></span><br><span class="line">deviceContext-&gt;SetPixelShader();    <span class="comment">//Pass 1</span></span><br><span class="line">deviceContext-&gt;SetPipelineState();  <span class="comment">//Pass 1 State</span></span><br><span class="line">deviceContext-&gt;DrawIndices();       <span class="comment">//Pass 1 draw call</span></span><br><span class="line"></span><br><span class="line">deviceContext-&gt;SetVertexShader();   <span class="comment">//Pass 2</span></span><br><span class="line">deviceContext-&gt;SetPixelShader();    <span class="comment">//Pass 2</span></span><br><span class="line">deviceContext-&gt;SetPipelineState();  <span class="comment">//Pass 2 State</span></span><br><span class="line">deviceContext-&gt;DrawIndices();       <span class="comment">//Pass 2 draw call</span></span><br></pre></td></tr></table></figure></p><p>每个Pass可以认为是一个多层材质的一层，在渲染时共用模型数据。大部分情况下每个Pass可以在DeferredContext中绘制最后依次将CommandList进行绘制。（在调用DrawCall的时候Pass之间是一定是有先后顺序的，在Unity的ShaderLab中使用的是<code>Queue</code>这个Tag对Pass的调用进行排序。）</p><p>之前思考过上每个Pass可以设置不同的RenderTarget，如果两个Pass之间没有先后的依赖关系，GPU应该可以同时进行绘制。但是这层的优惠应该是在驱动层做的优化，GPU在进行一个Shader绘制的时候是不是会使用掉所有的Streaming Multiprocessor，多个Pass能不能并行计算。可能需要了解更多GPU架构方面的知识。</p><h3 id="为什么需要多通道渲染"><a href="#为什么需要多通道渲染" class="headerlink" title="为什么需要多通道渲染"></a>为什么需要多通道渲染</h3><p>上面描述了多通道渲染大概的实现方式，通常情况下的着色器效果其实在一个Pass里就可以完成。但是很多复杂的效果可能需要对渲染对象进行多次的渲染最后才能计算出最终的颜色。例如一些光照计算，阴影贴图实现阴影等等效果。在多通道渲染的每个Pass之间是可以使用Blend混合，Stencil模板以及自定义深度测试和计算。这样在不同Pass之间就可以依次把每个通道计算的颜色深度和模板进行了混合。不需要耗费额外的DrawCall来把多次渲染的结果进行一个Merge（类似Unity中的Graphics.Bilt操作）</p><p>多通道渲染的设计方式使得多个DrawCall绘制结果的混合更加简便，实际上并不会在图像API层面提升性能和运算量。</p>]]></content>
      
      <categories>
          
          <category> Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DirectX </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Effective C++ 阅读笔记</title>
      <link href="/2017/07/17/effective-cpp-note/"/>
      <url>/2017/07/17/effective-cpp-note/</url>
      <content type="html"><![CDATA[<p>effective c++ 读完有一种醍醐灌顶的感觉。之前使用C++编程时在许多结构以及用法上都模糊不清，对于不同的需求可能有多种不同的实践，但是并不了解什么才是最佳实践或者说是有没有最佳实践。Effective可以给你一些答案。</p><hr><p>4.避免对象在初始化之前使用它<br>不同编译单元内的 non-local static对象 初始化先后顺序的处理<br>将该对象声明在为函数的 local static 对象</p><p>为内置类型对象进行初始化 在方法中的内置类型对象c++不保证初始化他们</p><p>5.了解c++默默编写调用了哪些函数</p><p>c++会在默认情况下生成 析构，复制构造 复制赋值函数<br>如果没有定义默认构造函数 则会自动生成构造函数<br>【默认生产的析构函数是非virtual 除非基类的析构函数是virtual的】</p><p>自动创建的赋值构造函数会把每一个non-static成员拷贝到目标对象</p><p>如果在一个含有reference成员的class内支持赋值操作 必须自行定义copy assignment<br>基类的copy assignment为private 则也无法自动生成copy assignment</p><p>6.阻止编译器自动生成函数<br>声明private 的复制构造与赋值构造函数 不定义，阻止使用赋值构造</p><p>不定义只生命会在link期报错而不是编译期，可以创建一个基类来实现防止拷贝构造<br>protected： 构造函数，析构函数<br>private：复制构造，赋值构造</p><a id="more"></a><p>7.对于那些不作为基类的class 声明virtual方法会增加内存大小 虚函数表vptr<br>std::string 不含有任何virtual函数 不能作为基类<br>c++ 没有sealed的禁止派生的机制</p><p>带有多态性质的base class 应该声明一个virtual析构函数<br>class如果不是为了作为基类使用，不该声明virtual析构</p><p>8.析构函数中的异常<br>std::abort() 强制结束<br>析构函数要捕获任何异常，swallow or abort<br>提供一个方法进行析构</p><p>9.不要在构造函数或析构函数中调用virtual<br>构造函数内的virtual函数不会调用derived 对象的实现<br>确定构造函数和析构函数内部不会调用任何热virtual函数</p><p>替代实现方式是创建一个非virtual方法，将参数传递到基类</p><p>10.operator= 返回一个reference to <em>this<br>int x,y,z;x=y=z=15<br>+= -= </em>= =</p><p>11.在operator中处理自我赋值</p><p>w&amp; operator=(const w&amp; rhs){<br>    if(this == &amp;rhs) return *this;    //identity test<br>}</p><p>手动控制顺序</p><p>使用copy and swap 交换数据</p><p>copy assignment 声明为by value形式 然后直接使用swap</p><ol start="12"><li>复制对象时不要忘记任何一个成员<br>derived class 的复构造函数必须复制其base class的成分。调用base class 的cctor 在初始化列表中。</li></ol><p>13.以对象管理资源</p><p>auto_ptr-&gt;unique_ptr 在对象释放的时候自动delete<br>RAII 资源取得的时机便是初始化时机</p><p>auto_ptr如果通过复制构造或者赋值构造 复制 自身会变成null</p><p>RCSP reference-counting smart pointer<br>shared_ptr</p><p>智能指针在析构时都是调用 delete 而不是delete []</p><p>14.资源管理中小心复制行为<br>抑制复制 使用引用计数</p><p>15.在资源管理类中提供对原始资源的访问<br>get() 方法暴露原始资源 或者使用隐式转换<br>隐式转换会出现一些其他的问题</p><p>16.使用new 和 delete时要采取相同的形式<br>最好不要对数组形式做typedef 难以正确delete []</p><p>17.以独立语句new 对象置入智能指针<br>new对象置入智能指针中是 要独立调用 不然可能会由于异常导致一些奇怪的情形</p><p>19.设计class犹如设计type<br>type的对象如何被创建与销毁<br>对象的初始化与赋值有什么样的差别<br>对象如果以值类型传递会如何<br>什么是type的合法值<br>type的继承关系是什么<br>新的type需要什么样的类型转换<br>什么样的操作符对新的type是合理的<br>什么样的标准函数需要驳回 private<br>那些成员时public 与private的<br>是否是需要定义成模板</p><ol start="20"><li>用pass-by-reference-to-const 替换pass-by-value<br>pass by value会造成 对象的切割 变为基类对象 如有<br>内置类型使用值传递</li></ol><p>21.在必须返回对象时不要返回其引用<br>在堆上或栈上创建对象都会导致问题 直接返回其值类型 会多一次复制构造函数 但是避免了一些其他的问题</p><p>22.将成员变量声明为private<br>将成员变量封装到getter setter中 便于修改实现<br>成员变量内容发生改变时的破坏量越小</p><p>protected 变量在修改时也可能需要对大量的derived 类进行修改<br>protected成员像public成员一样缺乏封装性</p><ol start="23"><li>prefer non-member non-friend 替换membr函数</li></ol><p>把便利函数放在相同的namespace下面</p><p>24.若所有参数皆需要类型转换，请使用non-member函数</p><p>隐式转换的 operator重载，所有参数都要隐式转换时 不要定义在成员函数中</p><p>25.写一个不抛出异常的swap函数<br>pimpl模式 swap指针<br>默认的swap会创建一个temp对象</p><p>当std::swap效率不高是 提供一个swap成员函数，并确定该函数不抛出异常<br>提供一个member swap 也提供一个non-member 调用前者<br>using std::swap 然后调用swap</p><p>26.尽可能延后变量定义式的出现时间<br>定义变量 + 拷贝赋值 = 复制构造 减少构造函数的调用<br>变量在循环中定义 还是在循环外声明在循环内做赋值 那种效率更高？</p><p>27.尽量减少类型转换<br>(T)expr T(expr)<br>const_cast<t>()    消除const<br>dynamic_cast<t>()     向继承链上转换 可能耗费重大成本<br>reinterpret_cast<t>()    低级转换 bitwise?<br>static_cast<t>()    强迫隐士转换 non-const-&gt;const int-&gt;double void*-&gt;typed ptr<br>c++中一个对象可能有很多个布局地址，多重继承的每个基类带有一个offset</t></t></t></t></p><p>使用dynamic_cast 在一个base ptr上 操作derived class的方法，你认定他是指向derived instance</p><p>解决方式：在base type中定义一个virtual 方法</p><p>avoid cascading dynamic_cast -&gt;use virtual function</p><p>28.避免返回handles指向对象内部成分<br>返回成员变量的指针或引用  加上const 防止被修改<br>即使加上const也是危险的 可以通过该handler的方法的返回值进行修改</p><p>29.exception-safe code<br>copy and swap 实现强异常安全<br>all or none</p><p>30.透彻了解inline<br>inline 是对编译器的申请，而不是强制<br>隐喻地提出inline，class 内部的成员函数<br>inline 和template通常都被定义与头文件中<br>function template不一定要inline</p><p>由于编译时进行inline 编译器需要知道方法具体的实现（vm 可以在运行时进行inline）<br>template 也需要别置于头文件 实现模板需要知道template的具体实现</p><p>virtual 方法不能inline 因为虚函数表依赖运行时进行调用<br>通过函数指针产生的调用也不会inline</p><p>inline函数无法进行升级 需要重新编译 non-inline只需要重新链接</p><p>31.将文件间的编译依存关系降低至最低<br>如果可以使用 obj ref 或obj ptr实现就不要使用obj<br>如果可以，尽量以class声明替换class 定义</p><p>handle classes and interface classes<br>full and declearation-only forms header</p><p>32.确保public 继承为 is-a的关系<br>public inheritance means the relation of ‘is-a’</p><p>33.避免遮掩继承而来的名称<br>derived class 内的名称会覆盖base class内的名称</p><p>34.区分接口继承和实现继承</p><p>可以给pure virtual 函数提供定义，调用的唯一途径是class::function<br>impure virtual 函数 derived class 可以override<br>impure virtual 会在子类未声明的情况下默默继承基类的实现，缺省实现有时候会造成问题<br>解决方案 声明一个non-virtual 方法 再声明一个pure virtual 默认实现时调用non-virtual方法</p><p>pure virtual    继承接口<br>impure virtual    继承接口和一份默认实现<br>non virtual    继承接口和一份强制实现</p><p>35.考虑virtual 函数外的其他选择</p><p>public non-virtual 成员函数间接调用private virtual 函数 non-virtual interface(NVI)<br>template method 设计模式。<br>NVI不一定是private方法 也可以是protected<br>NVI替代public virtual函数</p><p>基于function pointer实现strategy模式</p><p>36.绝不要重新定义继承而来的non-virtual 函数<br>viruta函数是动态绑定的 non-virtual是非动态绑定的<br>重新定义基类的non-virtual会导致一些不可意料的情况，取决于声明的指针类型</p><p>37.不要重新定义继承而来的缺省参数<br>virtual函数是动态绑定的 但是缺省参数是静态绑定的<br>最终调用derived class的方法时会使用base class 的参数<br>C++为了运行效率对缺省参数的绑定实现为静态绑定<br>使用NVI避免重新编写缺省参数</p><ol start="38"><li>复合 is-implemented in terms of / has a</li></ol><p>39.明智而谨慎地使用private 继承<br>private 继承 编译器不会自动将一个derived class对象转换为base class 对象<br>private继承而来的所有成员在derived class 中都会变成private</p><p>private意味着只有实现部分被继承，接口部分应略去。<br>private inherit means is-implemented-in-terms-of</p><p>尽量使用复合，必要时才使用private 继承</p><p>不存在is-a的关系的两个class，一个需要访问另一个的protected成员，或需要重新定义其一个或多个virtual函数，可以使用private集成<br>private 集成可以造成EBO empty base optimize<br>40.明智而审慎地使用多重继承</p>]]></content>
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>c# Attribute 使用约束</title>
      <link href="/2017/07/01/csharp_attribute_constraint/"/>
      <url>/2017/07/01/csharp_attribute_constraint/</url>
      <content type="html"><![CDATA[<p>Attribute是C#中一个广泛使用的特性，通过使用Attribute对程序集中的类型进行标记，并通过Reflection实现一些特殊的需求，同时Attribute也可以在编译时储存一些静态信息。但是在使用Attribute时也有一些限制。</p><h2 id="问题的提出"><a href="#问题的提出" class="headerlink" title="问题的提出"></a>问题的提出</h2><p>目前工作中主要是编写与维护一套在Unity中使用的Continuous Integration 框架。在这套框架中大量使用了Attribute来对集成的第三方SDK进行标记，来进行一些处理。最初的做法是一些SDK，通过约定静态方法，在CI的其他阶段进行调用</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SDKA</span> :<span class="title">SDKBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ModifyConfig</span>(<span class="params"><span class="keyword">ref</span> Hashtable config</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//SDK do modify</span></span><br><span class="line">    &#125;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过反射调用该方法的代码如下</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SDKsModifyConfig</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Type[] sdktypes = assembly.GetTypes();</span><br><span class="line">  <span class="comment">//过滤所有的的SDK类型</span></span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="keyword">var</span> tsdk <span class="keyword">in</span> sdktypes)</span><br><span class="line">    &#123;</span><br><span class="line">        MethodInfo method = tsdk.GetMethod(<span class="string">"ModifyConfig"</span>, BindingFlags.Public | BindingFlags.Static | BindingFlags.NonPublic);</span><br><span class="line"></span><br><span class="line">        method.Invoke(<span class="literal">null</span>, config);</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这种调用方式，不太好的地方是参与开发SDK的人员必须约定用于反射的方法名，以及该方法的参数。每次接入SDK编写一个SDK的类型都需重新编写，容易造成错误（error-prone）。</p><a id="more"></a><p>如果我们使用在基类定义方法，在子类覆盖的形式，这样可以避免发生错误，同时IDE的自动完成可以帮助我们完成代码。但是这样在反射的时候就需要有类的对象，而其实我们所需要的方法是针对与类的静态方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SDKBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ModifyConfig</span>(<span class="params"><span class="keyword">ref</span> Hashtable config</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SDKA</span> :<span class="title">SDKBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">ModifyConfig</span>(<span class="params"><span class="keyword">ref</span> Hashtable config</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用Attribute"><a href="#使用Attribute" class="headerlink" title="使用Attribute"></a>使用Attribute</h2><p>另一中解决方式是将这些方法定义在Attribute中。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomSDKAttribute</span> :<span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ModifyConfig</span>(<span class="params"><span class="keyword">ref</span> Hashtable config</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="meta">CustomSDK</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SDKA</span> :<span class="title">SDKBase</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> type <span class="keyword">in</span> sdktypes)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Attribute.IsDefined(type,<span class="keyword">typeof</span>(CustomSDKAttribute)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> attrs = type.GetCustomAttributes(<span class="keyword">typeof</span>(CustomSDKAttribute), <span class="literal">true</span>);</span><br><span class="line">                CustomSDKAttribute sdkattr = attrs[<span class="number">0</span>] <span class="keyword">as</span> CustomSDKAttribute;</span><br><span class="line">                sdkattr.ModifyConfig(<span class="keyword">ref</span> config);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>将需要反射的方法放在Attribute的定义中后我们在反射了类获得Attribute之后可以直接调用该方法，不需要再反射方法了。</p><p>对于不同的SDK的类型需要不同的实现，我们可以定义一个Attribute的基类，通过Attribute的子类来实现</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">CustomSDK</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SDKA</span> :<span class="title">SDKBase</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="meta">CustomSDK_Impl</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SDKB</span>:<span class="title">SDKBase</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomSDKAttribute</span> :<span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ModifyConfig</span>(<span class="params"><span class="keyword">ref</span> Hashtable config</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomSDK_Impl</span> :<span class="title">CustomSDKAttribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">ModifyConfig</span>(<span class="params"><span class="keyword">ref</span> Hashtable config</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//覆盖基类的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Attribute的约束"><a href="#Attribute的约束" class="headerlink" title="Attribute的约束"></a>Attribute的约束</h2><p>我们知道在定义Attribute的时候可以给Attribute添加约束<code>AttributeUsage</code></p><p><code>[AttributeUsage(AttributeTargets.Class,AllowMultiple =false)]</code></p><p>但是只能通过AttributeUsage约束Attribute添加到程序集对象的类型，并不能约束Attribute修饰的对象的继承链等其他特性。也就是不能使用泛型和where关键字。这样就会导致我们给SDK定义的Attribute可以被任意使用其他类型的对象上，这是我们不愿意看到的。</p><p>由于我们是使用反射来查找所有标记为该Attribute的类型，缺少了类型的继承链约束后，无疑会造成一些隐患。但是由于C#语言本身不提供Attribute的类型约束，在google之后通过一个非常trick的方式解决了Attribute的约束问题。</p><p>我们将Attribute的定义声明在需要约束的基类中，并且使用<code>protected</code>修饰符</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SDKBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ModifyConfig</span>(<span class="params"><span class="keyword">ref</span> Hashtable config</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">AttributeUsage(AttributeTargets.Class, AllowMultiple = false)</span>]</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">class</span> <span class="title">CustomSDKAttribute</span> : <span class="title">Attribute</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ModifyConfig</span>(<span class="params"><span class="keyword">ref</span> Hashtable config</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样CustomSDKAttribute就只能在SDKBase的子类进行访问，下面的代码便会产生编译错误。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">CustomSDK</span>]<span class="comment">//Error:未找到类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestClassA</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就我们就相当与声明了<code>where T:SDKBASE</code>，对Attribute的使用进行了约束。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用Attribute定义的修饰符将Attribute修饰的对象加上约束。</p><p>对于将需要反射调用的方法存放在Attribute中还有一个好处是。在Unity开发中，如果我们只在Editor层面进行对这些方法的反射和调用，可以将该Attribute限定在编辑器环境，防止这部分代码污染最后编译的版本。</p><p><code>[System.Diagnostics.Conditional(&quot;UNITY_EDITOR&quot;)]</code></p><p>但是如果使用最初的反射方法的方式，这需要给所有的反射方法加上宏的限定，同时不一定可以使用<code>System.Diagnostics.Conditional</code>这个Attribute进行宏的约束。Conditional要求限定的方法必须是void的返回值。讲方法定义在Attribute中直接移除Attribute不受该约束限制</p>]]></content>
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> C# </tag>
            
            <tag> hack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DirectX-Notes</title>
      <link href="/2017/06/04/dirextx-learn-1/"/>
      <url>/2017/06/04/dirextx-learn-1/</url>
      <content type="html"><![CDATA[<p>​    图形API对往游戏引擎和渲染方向发展的Programmer来说是非常重要的一部分。大部分的情况下，对于实际的游戏开发来说，游戏引擎handle了大部分图像API的内容。但是如果单纯从游戏引擎hight-level去学习，会有一直停留在表面的学习，而不太了解底层核心的东西。目前流行的图形API有DirectX，OpenGL，Vulkan还有随着移动平台流行起来的OpenGL ES。对于图形API的选择当然是很重要的一部分。DX和OGL的pros cons有很多人在讨论了，初学选择哪个API，这个并不不是很重要。</p><a id="more"></a><p>​    在RasterTek <a href="http://www.rastertek.com/" target="_blank" rel="noopener">http://www.rastertek.com/</a> 上按照教程学习了几章DX11的教程，自己实现了一个小型的DX框架。封装了模型与贴图加载，Shader编译，Shader Reflect。类似于Unity的组件模型来管理场景，基础的光照等。由于不是太熟悉C++，同时也遇到了一些问题。下面总结一些理解和疑问。</p><h3 id="HLSL中的CBuffer使用"><a href="#HLSL中的CBuffer使用" class="headerlink" title="HLSL中的CBuffer使用"></a>HLSL中的CBuffer使用</h3><p>​    HLSL是directx的Shader脚本语言，和Cg的语法很像。VertexShader PixelShader 和一些SV的Semantic都类似。在写了几个不同的Shader之后，一些每个Shader会有一些都需要的参数和变量 如MVP的Matrix 光源信息等等。这些参数的值通过CBuffer传入GPU中进行运算。在MSDN的文档中写到根据参数更新的频率将需要的参数分散在不同的CBuffer中这样可以减少更新的次数。由于渲染管线的状态是不会清除的只会在下一次设置的时候覆盖。对于不更新的参数我们就可以减少调用设置状态的频率，从而提升帧率。那么这些参数要怎么划分就是一个结构设计的问题。</p><p>​    这里我们只考虑光照和Camera的信息。Matrix信息有World Matrix，View Matrix，Projection Matrix，这个World Matrix是模型坐标转世界坐标的矩阵 和物体相关，View Matrix与Projection Matrix只与Camera相关。那么对于一帧的渲染。Camera的Matrix只要设置一次而 每渲染每个物体调用DrawCall的时候都要重新设置WorldMatrix。而通常我们在顶点着色器中使用的是Matrix_MVP 三个矩阵相乘。那么是不是把WorldMatrix 与Camera的两个Matrix分开在两个Const Buffer就可以略微提升性能呢？还是说给Buffer设置值的开销大部分在指令的数量而小量数据的copy性能开销可以基本忽略不计呢？<br>​    还有一个问题就是对于这三个矩阵 我们可能在Shader中可能需要MV,VP MVP复合的矩阵进行特殊的计算，这部分矩阵运算是交给CPU预计算好传入shader中还是纯在GPU中进行计算呢？个人的感觉是应该留在GPU中进行计算 可以通过一些宏来简化调用，类似于Unity中cginc的使用。<br>​    对于光源信息来说可以单独使用一个buffer来进行光源信息的更新，包括LightMatrix LightColor LightRange等等，每一帧的渲染也只需要map一次ConstBuffer。而不是每次DrawCall都需要调用。</p><h3 id="EFFECT11-Shader-Framework"><a href="#EFFECT11-Shader-Framework" class="headerlink" title="EFFECT11 Shader Framework"></a>EFFECT11 Shader Framework</h3><p>​    HLSL可以使用#include “xxx” 来包含其他的hlsl文件。我们可以把一些公用的struct定义在这些文件中类似于Unity的.cginc文件。而如果在运行时编译就需要实现一个ID3DInclude 来处理Include的文件的加载和编译。</p><p>​    DirextX提供了Shader Reflector来获取编译后shader的参数信息和状态，这样我们就可以在运行时动态获取到这些信息来设置shader的参数和生产对应的CBuffer。DX11以前的版本提供了Effect 框架 而DX11中被移出变成扩展库了。Effect框架带有一些特定的语法来使用简化shader的编写和调用及状态设置。比如对于一个特定效果的渲染。我们需要设置ZBuffer的状态为ZWrite关闭，而这需要单独设置DepthStencilBufferState，是不能从shader中直接设置的。而Effect框架就可以在hlsl中定义这些信息然后可以自动设置这些渲染管线的状态。<br>​    类比于Unity中的ShaderLab语法。ShaderLab中的Blend Src Dst，ZWrite，Cull 等都是在shader中设置Pipeline的状态。Shader Lab可以说是也是一个Effect框架，不过它支持多平台可以同时编译成HLSL与GLSL。每个引擎一般都是实现自己的Shader Framework，定义自己的shader语法和一些semantic。毕竟要处理多平台的兼容性，同时要简化shader的编写，提升开发效率。</p><h3 id="Defferred-Context-与Command-List"><a href="#Defferred-Context-与Command-List" class="headerlink" title="Defferred Context 与Command List"></a>Defferred Context 与Command List</h3><p>​    DX11中的Deferred Context可以把绘制的指令和设置pipeline状态的指令记录在Command List中，然后进行回放。这样可以减少CPU的overhead。对于一个在场景中要渲染的物体 如果他的位置坐标参数等都不发生变化，那么他可以使用上一帧的Command List进行渲染，从而减少了这部分状态参数重设的CPU开销。我们可以类比Unity中的CommandBuffer，在Unity中CommandBuffer只是用来扩展RenderPipeline的，底层的原理应该也是使用Command List。</p><h3 id="Material对象"><a href="#Material对象" class="headerlink" title="Material对象"></a>Material对象</h3><p>​    DX11中其实是没有Material的对象的，而引擎中常有材质的概念。Material可以理解为shader加上管线的状态以及传入管线的参数与贴图数据等等。这个概念可以和effect框架中的effect等价。Material通常是引擎自己实现的。</p><p>关于图形API 个人的感觉是API用法等都是简单的，重要的是怎样去架构一整个复杂的3D程序 CPU和GPU协同，最大幅度提升渲染效率。多线程渲染，各类资源的管理 互相作用。GPU指令如何调用能够最优，这些都是设计上的问题需要很多的实际开发经验才能总结出来。所以最好的方式应该是参考一个开源的框架或者是小型的引擎来学习它们是如何架构的。</p>]]></content>
      
      <categories>
          
          <category> Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DirectX </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello Lua</title>
      <link href="/2017/03/26/hello-lua/"/>
      <url>/2017/03/26/hello-lua/</url>
      <content type="html"><![CDATA[<p>在游戏开发中，Lua是一种比较热门的轻量级脚本语言。由C实现的Lua可以很好得和C/C++进行交互，同时它可以很方便地和和各种语言结合进行跨平台开发。<br>特别是在当前最流行的游戏Unity中，为了实现C#脚本热更新，Lua几乎是唯一的解决方案，各种基于Lua的库层出不穷。一直在写C#脚本，还是有必要学习Lua。</p><p>###Lua初见</p><p>一开始就直接打开Lua官方的Reference Manual<br><a href="http://www.lua.org/manual/5.3/contents.html" target="_blank" rel="noopener">Lua Reference Manual </a></p><p>接下来下载好Lua的binary版本，开始学习基本的语法<br><a href="http://www.runoob.com/lua/lua-tutorial.html" target="_blank" rel="noopener">Lua 基础教程</a></p><p>总体感觉Lua非常的轻巧<br>基础的数据类型也只有<code>nil boolean number string function userdata thread table</code> (整形和浮点都是number 想起了SQLite)<br>动态类型语言和Javascript一样<br>结尾不需要；和Python一样<br>函数可以是多返回值<br>没有自带的++ +=等运算符，写的时候特别难受…T_T</p><p>但是有metatable可以进行任意的扩展，这个metatable给我的感觉就像是JS中的prototype</p><a id="more"></a><p>###定个小目标</p><p>在熟悉了基本的语法和运算后，准备试试Lua的热更新。之前在github发现了一个GUI库imgui，imgui是一个immediate mode gui库。什么是immediate mode gui呢，就是和通常的事件回调式的GUI框架不同的，所有的UI逻辑是线性的，和Unity中的EditorGUI一样，需要不断的刷新。大概就是下面代码的样子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gui.Label(&quot;This is a label&quot;);</span><br><span class="line">if(gui.button(&quot;This is a button&quot;))</span><br><span class="line">&#123;</span><br><span class="line">//process button click</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>工作中一直在写一些Unity的插件及编辑器脚本，挺喜欢IMGUI这种快速代码实现UI的模式，但是也是有缺点的，比如UI逻辑太复杂时候，有可能会影响绘制帧率造成卡顿。或者是太复杂的UI结构代码的可读性就大大降低。<br>现在我们有了Lua 那么我们是不是可以用IMGUI绘制一个文本编辑器，然后在里面编写Lua脚本，通过Lua调用  C++的imgui的方法来更新UI呢。<br>这样就像写Unity的Editor扩展一样，但是不需要重新编译整个项目，加载不同的Lua脚本就能实现热更新UI。</p><p>总结起来我们需要做一下几步</p><ul><li>在windows下开发 windows程序，调用imgui C++库</li><li>配置Lua环境 执行Lua脚本</li><li>编写Lua调用imgui的C函数，互调用操作</li><li>在imgui中刷新Lua脚本</li></ul><h3 id="开始实现"><a href="#开始实现" class="headerlink" title="开始实现"></a>开始实现</h3><p><strong>创建工程</strong><br>imgui在github上的repo有demo 我们直接拿来改就行了。选了用opengl进行渲染，而不是dx。毕竟有GLFW GLEW比DX的初始化快多了。</p><p><strong>配置Lua</strong><br>把几个Lua头文件的目录加入Include</p><ul><li>Lua.h lualib.h 定义了Lua的基本方法</li><li>lauxlib.h 里面有一些比较常用的扩展方法</li><li>luaconf.h 用来控制模块的开关</li></ul><p>Lib就只有一个lua53.lib</p><p><strong>Lua和C++的互调用</strong><br>处理Lua与C++的互调用都需要通过Lua C Api来进行</p><p>在Lua5.3中 需要维护一个lua_State 来进行互操作<br>Lua调用C++需要先定义对应的方法，所有方法都必须带有lua_State的参数，因为Lua和C交互是通过维护一个栈来实现的。Lua调用方法时会先把方法和参数一个个push入栈，对应的C方法会pop出参数执行完再把结果压入栈返回给Lua的脚本<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">luaTestFunc</span><span class="params">(lua_State *state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//some implement</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化lua_State</span></span><br><span class="line">lua_State * lstate = luaL_newstate();</span><br><span class="line"><span class="comment">//加载lua基础库</span></span><br><span class="line">luaL_oepnlibs(lstate);</span><br><span class="line"><span class="comment">//注册方法</span></span><br><span class="line">lua_register(lstate,<span class="string">"luaTestFunc"</span>,luaTestFunc);</span><br></pre></td></tr></table></figure></p><p>接下来就可以直接在Lua中调用<code>luaTestFunc()</code></p><p>github上有imgui lua的wrap 我们可以直接用，就不需声明那么多方法了</p><p>C++调用Lua方法<br>使用<code>luaL_loadstring(lua_State*,const char * luacode)</code> 来加载代码<br>加载完成后我们要把需要调用的方法push到栈顶，然后调用<code>lua_call()</code> 就可以执行了。需要注意的是调用了<code>lua_call</code> 之后我们使用<code>lua_getglobal()</code> push到栈顶的方法会被pop出栈。在imgui中每一帧循环都要调用imgui的绘制方法，所以如果要重复调用一个方法就需要在调用前讲其push到栈顶（不知道有没有其他的方法可以实现）。不这样操作可能会报错就会出现如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lua syntax error:attempt to call a nil value</span><br><span class="line">lua syntax error:attempt to call a string value</span><br><span class="line">lua syntax error:attempt to call a string value</span><br></pre></td></tr></table></figure></p><p>这样的错误其实是调用lua_call 发现在栈顶的不是函数先报错 nil value，然后lua会把这个error string push到栈顶 所以下次调用call就会返回string value，无限循环下去…</p><p>更多的Lua C++的互调用可以参考<br><a href="https://csl.name/post/lua-and-cpp/" target="_blank" rel="noopener">Lua C++互调用</a></p><p><strong> 重新加载编写好的Lua脚本 </strong><br>当我们更新了lua脚本之后需要重新加载，首先调用 <code>lua_close()</code> 回收lua_State，接着就是重新加载lua基本库和imgui的库。这一步加载库是比较耗时间的，不知道有没有其他的方式可以动态卸载掉加载的代码块，再重新加载Lua脚本。</p><p>###总结<br>Lua的栈操作还是不太习惯，总体感觉Lua是一个很简洁易用的脚本语言。模块管理，基本库，metadata等特性还需要再深入接触一下。<br>在调试互调用的时候还是踩了很多坑，需要好好了解下Lua C Api。基于Lua的imgui UI扩展还会继续完善完善。</p>]]></content>
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Unity shader Note</title>
      <link href="/2016/12/11/Unity-shader-Note/"/>
      <url>/2016/12/11/Unity-shader-Note/</url>
      <content type="html"><![CDATA[<h3 id="光照基础"><a href="#光照基础" class="headerlink" title="光照基础"></a>光照基础</h3><p>辐照度irradiance</p><p>散射scattering 吸收 absorption<br>散射只改变光的方向 吸收只改变光线的密度和颜色</p><p>光线进入如物体会发生折射refraction和投射transmission 以及被散射到外部的反射reflection<br>区别不同的散射方向 高光反射 specular 漫反射diffuse</p><p>出射度 exitance 辐照度和出射度满足线性关系 比值就是漫反射和高光反射的属性</p><p>BRDF (Bidirectional Reflection Distribution Function)</p><p>标准光照模型 direct light<br>自发光 emissive 高光specular 漫反射diffuse 环境光ambient</p><p>diffuse Lambert’s Law<br>$$<br>c_{diffuse} = (c_{light} <em> m_{diffuse})max(0,n</em>l)<br>$$</p><p>光源颜色<em>漫反射材质颜色</em>亮度值<br>Phong光照模型<br>$$<br>C_{specular} = (c_{light} <em> m_{specular})max(0,v</em>r)^{m_{gloss}}<br>$$</p><p>Blinn-Phong<br>$$<br>h = \frac{v+l}{|v+l|}<br>C_{specular} = (c_{light} <em> m_{specular})max(0,n</em>h)^{m_{gloss}}<br>$$<br>Phong shading 逐像素光照 Gouraud shading 逐顶点光照<br>各向同性isotropic  各向异性anisotropic</p><a id="more"></a><h3 id="坐标转换"><a href="#坐标转换" class="headerlink" title="坐标转换"></a>坐标转换</h3><p>投影矩阵</p><p>N = near plane<br>F = far plane<br>A = aspect ratio<br>FOV =field of view<br>S = size</p><p><code>UNITY_UV_STARTS_AT_TOP</code> DX平台和OpenGL差别<br><code>_MainTex_TexelSize.y &lt; 0</code> 判定是否开启抗锯齿<br>DX9/11不支持在vertex shader中采样纹理 使用<code>tex2D()</code> 使用 <code>tex2DLOD(texture2d tex,float4 uv)</code>替代</p><table><thead><tr><th>类型</th><th>精度</th></tr></thead><tbody><tr><td>float</td><td>32bit 浮点</td></tr><tr><td>half</td><td>16bit 浮点 -60000 ~ +60000</td></tr><tr><td>fixed</td><td>11bit -2.0~+2.0</td></tr></tbody></table><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>#pragma target 2.0</td><td>DX9 SM2.0 不支持对顶点纹理采样，不支持显示LOD纹理采样</td></tr><tr><td>#pragma target 3.0</td><td>DX9 SM3.0支持顶点纹理采样</td></tr><tr><td>#pragma target 4.0</td><td>DX10 SM4,0 支持几何着色器</td></tr><tr><td>#pragma target 5.0</td><td>DX11 SM5.0</td></tr></tbody></table><p>对向量进行转换<br><code>mul(v,(float3x3)_World2Object)</code> == <code>mul(_Object2World,v)</code></p><h3 id="屏幕坐标"><a href="#屏幕坐标" class="headerlink" title="屏幕坐标"></a>屏幕坐标</h3><p>计算屏幕位置<code>ComputeScreenPos(float4 projectionPos)</code></p><p><code>ObjSpaceViewDir(float4 objectpos)</code></p><h4 id="采样Depth-Texture-World"><a href="#采样Depth-Texture-World" class="headerlink" title="采样Depth Texture World"></a>采样Depth Texture World</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v2f</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">...</span><br><span class="line">    float4 pos ：SV_POSITION;</span><br><span class="line">float3 ray : TEXCOORD1;</span><br><span class="line">  float4 screenUV : TEXCOORD0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">v2f o;</span><br><span class="line">  o.pos = mul(UNITY_MATRIX_MVP,float4(v.pos,<span class="number">1</span>));</span><br><span class="line">  o.screenUV = ComputeScreenPos(o.pos);</span><br><span class="line"> o.ray = mul(UNITY_MATRIX_MV,float4(v.pos,<span class="number">1</span>).xyz * float3(<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sampler2D_float _CameraDepthTexture;</span><br><span class="line"></span><br><span class="line">fixed4 frag(v2f i): SV_Target</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">float</span> depth = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture,i.screenUV.xy/i.screenUV.w);</span><br><span class="line">  depth = Linear01Depth(depth); <span class="comment">//sample depth texture</span></span><br><span class="line">i.ray = i.ray *(_ProjectionParams.z / i.ray.z);</span><br><span class="line">float4 vpos = float4(i.ray* depth,<span class="number">1</span>); <span class="comment">//view pos</span></span><br><span class="line">  float3 wpos = mul(unity_CameraToWorld,vpos).xyz; <span class="comment">//world pos</span></span><br><span class="line">  float3 opos = mul(unity_WorldToObject,float4(wpos,<span class="number">1</span>)).xyz;<span class="comment">//object pos </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Unity中实现Post Process Volumetric Lighting</title>
      <link href="/2016/12/04/post-process-volumetric-lighting/"/>
      <url>/2016/12/04/post-process-volumetric-lighting/</url>
      <content type="html"><![CDATA[<p>一直觉得体积光之类的效果很酷炫，在shadertoy也看到了很多惊艳的ray marching实现。看了一些文章和Paper相关的内容之后决定在Unity中实现一遍，记录下来。文中都是个人的理解，肯定会有一些错误，希望能有所帮助。</p><p><img src="/images/161204_volumetric_light.png" alt="Volumetric LightING"></p><ul><li>自定义Shader中采样Shadow Map</li><li>通过CameraDepthTexture计算世界坐标</li><li>Ray Marching 计算scatter</li></ul><h2 id="自定义shader中采样shadow-Map"><a href="#自定义shader中采样shadow-Map" class="headerlink" title="自定义shader中采样shadow Map"></a>自定义shader中采样shadow Map</h2><h3 id="关于shadowmap"><a href="#关于shadowmap" class="headerlink" title="关于shadowmap"></a>关于shadowmap</h3><p>在unity中，每个开启投射阴影的光源都会计算一张shadowMap。shadowMap可以用于实现screen space shadow。简单的说对于screen space的一个像素我们可以通过这个像素的深度值来获取该像素的世界坐标，要判断这个像素是不是在阴影之中，就是该点朝光源方向（平行光就是光源方向，点光源就是光源位置）是否被其他物体阻挡，然而在shader中发射一条射线进行碰撞检测是不现实的。而shadowmap的实现方式是在光源位置渲染整个场景，记录下深度信息储存在shadowmap中。<br>如果屏幕空间的一个像素P1，其对应世界坐标映射在shadowmap的点P2。如果P1的深度值大于P2的深度值，则P1处于阴影之中。</p><a id="more"></a><p>渲染shadowmap要尽可能把主摄像机视椎体内的对象全部包括在内部，这样所有的像素才能在shadowmap中找到对应的点。如果一个点在屏幕空间中但是其对应的世界坐标不在shadowmap中一般设定其不在阴影中。在光源处渲染场景的视锥要包括所有对象的同时又不能太大。太大在相同大小的shadowmap情况下会导致阴影的精度降低。</p><p>具体的shadowmap渲染有许多不同的实现方式，Cascaded Shadow Maps可以解决一些ShadowMap的精度问题。具体如何选取光源位置的视椎体可以阅读<a href="http://blog.csdn.net/zjull/article/details/11740505" target="_blank" rel="noopener">基于Shadow Map的阴影实现</a>。</p><h3 id="在shader中获取shadowmap"><a href="#在shader中获取shadowmap" class="headerlink" title="在shader中获取shadowmap"></a>在shader中获取shadowmap</h3><p>在shader中可以通过 <code>_CameraDepthTexture</code>直接获取到当前的深度图进行采样，然而untiy没有直接提供这样的对象，通过其他方式获取到shadowmap。<br><a href="https://docs.unity3d.com/Manual/SL-BuiltinMacros.html" target="_blank" rel="noopener">Unity SL-BuiltinMacros</a>中提供了方法来对shadowmap进行采样，但并没有具体的使用方法。</p><table><thead><tr><th><strong>Macro:</strong></th><th><strong>Use:</strong></th></tr></thead><tbody><tr><td>UNITY_DECLARE_SHADOWMAP(tex)</td><td>Declares a shadowmap Texture variable with name “tex”.</td></tr><tr><td>UNITY_SAMPLE_SHADOW(tex,uv)</td><td>Samples shadowmap Texture “tex” at given “uv” coordinate (XY components are Texture location, Z component is depth to compare with). Returns single float value with the shadow term in 0..1 range.</td></tr></tbody></table><p>经过了一番（漫长）搜索之后终于找到了使用的方式，要通过unity提供的command buffer把光源的shadowmap Texture 传递给shader。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private Light m_light;</span><br><span class="line">private CommandBuffer m_cbShadowMap;</span><br><span class="line">...</span><br><span class="line">void OnRenderObject()</span><br><span class="line">    &#123;</span><br><span class="line">        if (m_light == null) m_light = GetComponent&lt;Light&gt;();</span><br><span class="line">        if (m_cbShadowMap == null)</span><br><span class="line">        &#123;</span><br><span class="line">            m_cbShadowMap = new CommandBuffer();</span><br><span class="line">            m_cbShadowMap.name = &quot;ShadowMap&quot;;</span><br><span class="line">            m_cbShadowMap.SetGlobalTexture(&quot;_DirectionalLightShadowMap&quot;, new RenderTargetIdentifier(BuiltinRenderTextureType.CurrentActive));</span><br><span class="line">        &#125;</span><br><span class="line">        if (m_light.GetCommandBuffers(LightEvent.AfterShadowMap).Length == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            m_light.AddCommandBuffer(LightEvent.AfterShadowMap, m_cbShadowMap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在LightEvent.AfterShadowMap时把该光源的rendertexure 设置为全局变量 <code>_DirectionalLightShadowMap</code>，这样就能在shader中获取shadowmap了<code>sampler2D _DirectionalLightShadowMap;</code></p><h3 id="采样shadowMap"><a href="#采样shadowMap" class="headerlink" title="采样shadowMap"></a>采样shadowMap</h3><p>待续</p><h2 id="通过CameraDepthTexture计算世界坐标"><a href="#通过CameraDepthTexture计算世界坐标" class="headerlink" title="通过CameraDepthTexture计算世界坐标"></a>通过CameraDepthTexture计算世界坐标</h2><p>待续</p><h2 id="Ray-Marching-计算scatter"><a href="#Ray-Marching-计算scatter" class="headerlink" title="Ray Marching 计算scatter"></a>Ray Marching 计算scatter</h2><p>待续</p>]]></content>
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Ray marching </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
